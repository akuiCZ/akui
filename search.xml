<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2048]]></title>
    <url>%2F2018%2F10%2F09%2F2048%2F</url>
    <content type="text"><![CDATA[&lt;!DOCTYPE html&gt; 2048-game #game { display: none; position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; background-color: #9DA5C3; opacity: 0.5; z-index: 1; } .clear:after { content: “”; display: table; clear: both; } .left { float: left; } .right { float: right; } .scoreShow { height: 50px; text-align: center; line-height: 50px; } .model { text-decoration: none; color: white; background-color: #bbada0; font-size: 36px; border-radius: 10px; } .head { width: 480px; height: 50px; margin: 0 auto; font-size: 25px; } #gridPanel { width: 480px; height: 480px; margin: 0 auto; background-color: #bbada0; border-radius: 10px; position: relative; z-index: 1; } .grid, .cell { width: 100px; height: 100px; border-radius: 6px; } .grid { background-color: #ccc0b3; float: left; margin: 16px 0 0 16px; } .cell { position: absolute; font-size: 60px; text-align: center; line-height: 100px; color: #fff; } .n2 { background-color: #eee3da } .n4 { background-color: #ede0c8 } .n8 { background-color: #f2b179 } .n16 { background-color: #f59563 } .n32 { background-color: #f67c5f } .n64 { background-color: #f65e3b } .n128 { background-color: #edcf72 } .n256 { background-color: #edcc61 } .n512 { background-color: #9c0 } .n1024 { background-color: #33b5e5 } .n2048 { background-color: #09c } .n4096 { background-color: #a6c } .n8192 { background-color: #93c } .n2, .n4 { color: #776e65 } #gameover { width: 100%; display: none; position: fixed; left: 50%; right: 50%; top: 148px; width: 220px; height: 200px; border-radius: 10px; background-color: white; margin-left: -110px; text-align: center; z-index: 5; } #gameover&gt;a { display: inline-block; width: 170px; height: 50px; border-radius: 10px; text-decoration: none; background-color: #9F8D77; color: white; font-size: 36px; } Score: 3X3 4X4 5X5 6X6 Try again var arr = []; function $(id) { return document.getElementById(id); } function C(cls) { return document.getElementsByClassName(cls); } var obj = { ROW: 4, CELL: 4, r: 0, c: 0, f: 0, //r行 c列 f查找的下一位置 keyCd: 0, score: 0, createEle: 0, //是否需要创建元素 eleFragment: “”, //文档片段变量 //游戏开始 gameStart: function() { obj.init(); document.onkeydown = function(e) { //自动获得事件对象 switch (e.keyCode) { //判断按键号 case 37: obj.keyCd = 1; obj.moveLeft(); break; case 38: obj.keyCd = 2; obj.moveUp(); break; case 39: obj.keyCd = 1; obj.moveRight(); break; case 40: obj.keyCd = 2; obj.moveDown(); break; } $(“score”).innerHTML = obj.score; //更新分数 } }, //初始化 init: function() { obj.eleFragment = document.createDocumentFragment(); for (r = 0; r &lt; obj.ROW; r++) { arr.push([]); for (c = 0; c &lt; obj.CELL; c++) { arr[r][c] = 0; if (obj.createEle == 1) { obj.create(r, c); } } } if (obj.createEle == 1) { obj.createEle = 0; $(“gridPanel”).innerHTML = “”; //清空原有的元素 $(“gridPanel”).appendChild(obj.eleFragment); //添加元素 } obj.score = 0; $(“score”).innerHTML = obj.score; $(“game”).style.display = “none”; $(“gameover”).style.display = “none”; obj.random(); //开始游戏随机生成两个数 obj.random(); obj.updateView(); }, //创建div元素，添加到gridPanel中 create: function(r, c) { var grid, cell; var increment = 14, grWidth, grHeight, grMarginTop, grMarginLeft, ceWidth, ceHight; grid = document.createElement(“div”); cell = document.createElement(“div”); grid.id = “g” + r + c; grid.className = “grid”; cell.id = “c” + r + c; cell.className = “cell”; if (obj.ROW == 3) { increment = 24; } else if (obj.ROW == 4) { increment = 18; } grWidth = grHeight = ceWidth = ceHight = 66 + (6 - obj.ROW) increment; //优化后 grMarginTop = grMarginLeft = (480 - grWidth obj.ROW) / (obj.ROW + 1); grid.style.width = grWidth + “px”; grid.style.height = grHeight + “px”; grid.style.marginTop = grMarginTop + “px”; grid.style.marginLeft = grMarginLeft + “px”; cell.style.width = ceWidth + “px”; cell.style.height = ceHight + “px”; cell.style.top = grMarginTop + r (grMarginTop + ceWidth) + “px”; cell.style.left = grMarginLeft + c (grMarginLeft + ceHight) + “px”; cell.style.lineHeight = ceHight + “px”; cell.style.fontSize = 30 + (6 - obj.ROW) 10 + “px”; //优化前 /if (obj.ROW == 3) { grid.style.width = “140px”; grid.style.height = “140px”; grid.style.margin = “15px 0 0 15px”; cell.style.width = “140px”; cell.style.height = “140px”; cell.style.top = 15 + r 155 + “px”; //设置距离上一位置的高度 cell.style.left = 15 + c 155 + “px”; //设置离左一位置的距离 cell.style.lineHeight = “140px”; } else if (obj.ROW == 4) { grid.style.width = “100px”; grid.style.height = “100px”; grid.style.margin = “16px 0 0 16px”; cell.style.width = “100px”; cell.style.height = “100px”; cell.style.top = 16 + r 116 + “px”; cell.style.left = 16 + c 116 + “px”; cell.style.lineHeight = “100px”; } else if (obj.ROW == 5) { grid.style.width = “75px”; grid.style.height = “75px”; grid.style.margin = “17.5px 0 0 17.5px”; cell.style.width = “75px”; cell.style.height = “75px”; cell.style.top = 17.5 + r 92.5 + “px”; cell.style.left = 17.5 + c 92.5 + “px”; cell.style.fontSize = “40px”; cell.style.lineHeight = “75px”; } else if (obj.ROW == 6) { grid.style.width = “66px”; grid.style.height = “66px”; grid.style.margin = “12px 0 0 12px”; cell.style.width = “66px”; cell.style.height = “66px”; cell.style.top = 12 + r 78 + “px”; cell.style.left = 12 + c 78 + “px”; cell.style.fontSize = “30px”; cell.style.lineHeight = “66px”; }/ obj.eleFragment.appendChild(grid); obj.eleFragment.appendChild(cell); }, //随机产生一个新的数 random: function() { while (1) { var row = Math.floor(Math.random() obj.ROW); var cell = Math.floor(Math.random() obj.CELL); if (arr[row][cell] == 0) { //判断生成的随机数位置为0才随机生成2或4 arr[row][cell] = (Math.random() &gt; 0.5) ? 4 : 2; break; } } // var row = Math.floor(Math.random() 4); // var cell = Math.floor(Math.random() 4); // if (arr[row][cell] == 0) { //判断生成的随机数位置为0才随机生成2或4 // arr[row][cell] = (Math.random() &gt; 0.5) ? 4 : 2; // return; // } // obj.random();//递归影响执行效率 }, //更新页面 updateView: function() { var win = 0; for (r = 0; r &lt; obj.ROW; r++) { for (c = 0; c &lt; obj.CELL; c++) { if (arr[r][c] == 0) { //值为0的不显示 $(“c” + r + c).innerHTML = “”; //0不显示 $(“c” + r + c).className = “cell” //清除样式 } else { $(“c” + r + c).innerHTML = arr[r][c]; $(“c” + r + c).className = “cell n” + arr[r][c]; //添加不同数字的颜色 if (obj.ROW == 3 &amp;&amp; arr[r][c] == 1024) { win = 1; } else if (obj.ROW == 4 &amp;&amp; arr[r][c] == 2048) { win = 1; } else if (obj.ROW == 5 &amp;&amp; arr[r][c] == 4096) { win = 1; } else if (obj.ROW == 6 &amp;&amp; arr[r][c] == 8192) { win = 1; } } } } if (win == 1) { //通关 $(“game”).style.display = “block”; $(“gameover”).style.display = “block”; $(“Score”).innerHTML = “You win!Score:” + obj.score; } if (obj.isGameOver()) { //游戏失败 $(“game”).style.display = “block”; $(“gameover”).style.display = “block”; $(“Score”).innerHTML = “GAME OVER!Score:” + obj.score; console.log(“gameover”); } }, //游戏失败 isGameOver: function() { for (r = 0; r &lt; obj.ROW; r++) { for (c = 0; c &lt; obj.CELL; c++) { if (arr[r][c] == 0) { //有0还不是gameover return false; } else if (c != obj.CELL - 1 &amp;&amp; arr[r][c] == arr[r][c + 1]) { //左往右 前一个和下一个不相等 return false; } else if (r != obj.ROW - 1 &amp;&amp; arr[r][c] == arr[r + 1][c]) { //上往下 上一个和下一个不相等 return false; } } } return true; }, //查找下一个不为0的数值的位置 find: function(r, c, start, condition, direction) { if (obj.keyCd == 2) { //上下按键 if (direction == 1) { //向上按键 f++ for (var f = start; f &lt; condition; f += direction) { if (arr[f][c] != 0) { return f; } } } else { //向下按键 f– for (var f = start; f &gt;= condition; f += direction) { if (arr[f][c] != 0) { return f; } } } } else { //左右按键 if (direction == 1) { //左按键 f++ for (var f = start; f &lt; condition; f += direction) { if (arr[r][f] != 0) { return f; } } } else { //右按键 f– for (var f = start; f &gt;= condition; f += direction) { if (arr[r][f] != 0) { return f; } } } } return null; //循环结束仍然没有找到！=0的数值，返回null }, //左按键的处理 dealToLeft: function(r) { var next; for (c = 0; c &lt; obj.ROW; c++) { next = obj.find(r, c, c + 1, obj.CELL, 1); //找出第一个不为0的位置 if (next == null) break; //没有找到就返回 //如果当前位置为0 if (arr[r][c] == 0) { arr[r][c] = arr[r][next]; //把找到的不为0的数值替换为当前位置的值 arr[r][next] = 0; //找到的位置清0 c–; //再次循环多一次，查看后面否有值与替换后的值相同， } else if (arr[r][c] == arr[r][next]) { //如果当前位置与找到的位置数值相等，则相加 arr[r][c] = 2; arr[r][next] = 0; obj.score += arr[r][c]; } } }, move: function(itertor) { var before, //没处理前 after; //after处理后 before = arr.toString(); itertor(); //执行for函数 after = arr.toString(); if (before != after) { //前后对比，如果不同就update obj.random(); obj.updateView(); } }, moveLeft: function() { obj.move(function() { for (r = 0; r &lt; obj.ROW; r++) { obj.dealToLeft(r); } }) // if 当前位置 不为零 // 从当前位置，下一个成员开始，遍历， // 如果找到，与当前位置相等的数， // 两者相加，并把不为零的成员，设置为零 // 如果 当前位置是 零 // 从当前位置下一个成员开始遍历 // 如果找到 第一个不为零的成员 // 当前位置数值设置为这个不为零的成员的值 ，并且把那个不为零的成员设置为 0 }, //右按键处理 dealToRight: function(r) { var next; for (c = obj.CELL - 1; c &gt;= 0; c–) { next = obj.find(r, c, c - 1, 0, -1); //找出第一个不为0的位置 if (next == null) break; //没有找到就返回 //如果当前位置为0 if (arr[r][c] == 0) { arr[r][c] = arr[r][next]; //把找到的不为0的数值替换为当前位置的值 arr[r][next] = 0; //找到的位置清0 c++; //再次循环多一次，查看后面否有值与替换后的值相同， } else if (arr[r][c] == arr[r][next]) { //如果当前位置与找到的位置数值相等，则相加 arr[r][c] = 2; arr[r][next] = 0; obj.score += arr[r][c]; } } }, moveRight: function() { obj.move(function() { for (r = 0; r &lt; obj.ROW; r++) { obj.dealToRight(r); } }) }, //上按键处理 dealToUp: function(c) { var next; for (r = 0; r &lt; obj.ROW; r++) { next = obj.find(r, c, r + 1, obj.ROW, 1); //找出第一个不为0的位置 if (next == null) break; //如果当前位置为0 if (arr[r][c] == 0) { arr[r][c] = arr[next][c]; //把找到的不为0的数值替换为当前位置的值 arr[next][c] = 0; //找到的位置清0 r–; //再次循环多一次，查看后面否有值与替换后的值相同 } else if (arr[r][c] == arr[next][c]) { //如果当前位置与找到的位置数值相等，则相加 arr[r][c] = 2; arr[next][c] = 0; obj.score += arr[r][c]; } } }, moveUp: function() { obj.move(function() { for (c = 0; c &lt; obj.CELL; c++) { obj.dealToUp(c); } }) }, //下按键处理 dealToDown: function(c) { var next; for (r = obj.ROW - 1; r &gt;= 0; r–) { next = obj.find(r, c, r - 1, 0, -1); //找出第一个不为0的位置 if (next == null) { break; } //如果当前位置为0 if (arr[r][c] == 0) { arr[r][c] = arr[next][c]; //把找到的不为0的数值替换为当前位置的值 arr[next][c] = 0; //找到的位置清0 r++; //再次循环多一次，查看后面否有值与替换后的值相同 } else if (arr[r][c] == arr[next][c]) { //如果当前位置与找到的位置数值相等，则相加 arr[r][c] = 2; arr[next][c] = 0; obj.score += arr[r][c]; } } }, moveDown: function() { obj.move(function() { for (c = 0; c &lt; obj.CELL; c++) { obj.dealToDown(c); } }) } } window.onload = function() { obj.createEle = 1; obj.gameStart(); } //切换模式 function getModel(e) { //事件冒泡获取a元素 var a = e.target, modelValue = 4; if (a.nodeName == “A”) { if (a.innerHTML == “3X3”) { modelValue = 3; } else if (a.innerHTML == “4X4”) { modelValue = 4; } else if (a.innerHTML == “5X5”) { modelValue = 5; } else if (a.innerHTML == “6X6”) { modelValue = 6; } obj.ROW = obj.CELL = modelValue; obj.createEle = 1; //需要创建格子div元素的标志 obj.gameStart(); } } // var modelValue = parseInt($(“model”).value); // if (isNaN(modelValue)) { // modelValue = 4; //默认是44 // } // if (modelValue &lt;= 2 || modelValue &gt; 6) return; //2格或者大于6格无效 // obj.ROW = modelValue; // obj.CELL = modelValue; // obj.createEle = 1; // obj.gameStart(); // console.log(modelValue); // }]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>小游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[不知道为啥，总觉得数论很难，而noip2017的day1 t1给了我很大的心里阴影不管怎么样，也不能不管数论啊。。。 介绍首先，什么是卡特兰数呢Catalan数好像来自一个这样的问题一个栈的进栈序列为1,2,3，……，n，有多少个不同的出栈序列？ 我们来分析一下首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)*f(k-1)种，求和便是Catalan递归式。 还有一种分析对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。看图，其实就是问从A走到B有多少种走法（每次只能向右或向上走一个单位长度，就像对于栈只有进栈和出栈两种操作） 这个答案序列我们就把它称为Catalan数列，中文音译过来卡特兰，卡塔兰都行。 计算怎么得出卡特兰序列呢 令h(0)=1,h(1)=1，catalan数满足递推式：1C(n)= C(0)*C(n-1)+C(1)*C(n-2)+...+C(n-1)*C(0) (n&gt;=2) 不过有个更简单的式子，我一般用这个:1C(n)=C(n-1)*(4*n-2)/(n+1) 第一个递推式很容易推出来，第二个我不知道怎么推的，可能是第一个式子的简化吧，我不知道。 应用用到某些找规律题还是很舒服的，枚举前几个数，如果是1,2,5,14,42，要是我，我会毫不犹豫地敲卡特兰数列的。今天就遇到这样一道题 100%的数据是T≤50000，n≤200000 很明显是道数论题，然后我直接就懵了，暴力都不会打，我想可能会有公式，然后我就尝试着推一推，（也是受noip2017小凯的疑惑影响才要推公式，以下是我的错误推论，怕被我误导的跳过这一点）我手推把第四项算出来是14，第五项是42，然后计算了一下第六项是146（正确的是132，我也没法检验对错啊）然后就有了下面的思路： 看着是挺对的，之后我测试了题目给的大数据，就知道离爆零不远了 咳咳回归正题其实这题的答案就是一个Catalan数列，对于要取模的数用费马小定理,再加上快速幂就行了，我把快速乘也加上了，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int nnn=1,numm=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')nnn=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; numm=(numm&lt;&lt;1)+(numm&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return nnn*numm;&#125;const int p = 1000000007;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%p; xt=(xt+xt)%p; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax)%p;//ans=ans*a%p; ax=quick(ax,ax)%p;//a=a*a%p; bx&gt;&gt;=1; &#125; return anss;&#125;long long w[200005];int main()&#123; freopen("notitle.in","r",stdin); freopen("notitle.out","w",stdout); long long xx; w[1]=1; for(register int i=2;i&lt;=200003;++i) &#123; xx=pow(i+1,p-2); w[i]=quick(w[i-1],quick((4*i-2),xx))%p; &#125; int t=read(); for(register int i=1;i&lt;=t;++i) cout&lt;&lt;w[read()]&lt;&lt;endl; return 0;&#125; 某学长以前提到过Catalan数列，当时没细讲，我觉得没有那么重要，所以就没太在意。Catalan数列还是很有用的，这道题拉了我不少分，以后再见到答案是Catalan数列的题就不会轻易放过了。。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速——快速幂]]></title>
    <url>%2F2018%2F09%2F26%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[可能我的码风有些奇特吧。。。可我觉得挺好的呀 快速幂+快速乘 12345678910111213141516171819202122232425const int p = 1000000007;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%p; xt=(xt+xt)%p; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax);//ans=ans*a%p; ax=quick(ax,ax);//a=a*a%p; bx&gt;&gt;=1; &#125; return anss;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求单源最短路——Dijkstra]]></title>
    <url>%2F2018%2F09%2F02%2FDijkstra%2F</url>
    <content type="text"><![CDATA[迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 示例演示下面我求下图，从顶点v1到其他各个顶点的最短路径首先第一步，我们先声明一个dis数组，该数组初始化的值为：我们的顶点集T的初始化为：T={v1}既然是求 v1顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离v1顶点最近是 v3顶点。当选择了 2 号顶点后，dis[2]（下标从0开始）的值就已经从“估计值”变为了“确定值”，即 v1顶点到 v3顶点的最短路程就是当前 dis[2]值。将V3加入到T中。为什么呢？因为目前离 v1顶点最近的是 v3顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 v1顶点到 v3顶点的路程进一步缩短了。因为 v1顶点到其它顶点的路程肯定没有 v1到 v3顶点短.OK，既然确定了一个顶点的最短路径，下面我们就要根据这个新入的顶点V3会有出度，发现以v3 为弧尾的有： &lt; v3,v4 &gt;,那么我们看看路径：v1–v3–v4的长度是否比v1–v4短，其实这个已经是很明显的了，因为dis[3]代表的就是v1–v4的长度为无穷大，而v1–v3–v4的长度为：10+50=60，所以更新dis[3]的值,得到如下结果：因此 dis[3]要更新为 60。这个过程有个专业术语叫做“松弛”。即 v1顶点到 v4顶点的路程即 dis[3]，通过 &lt; v3,v4&gt; 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。然后，我们又从除dis[2]和dis[0]外的其他值中寻找最小值，发现dis[4]的值最小，通过之前是解释的原理，可以知道v1到v5的最短距离就是dis[4]的值，然后，我们把v5加入到集合T中，然后，考虑v5的出度是否会影响我们的数组dis的值，v5有两条出度：&lt; v5,v4&gt;和 &lt; v5,v6&gt;,然后我们发现：v1–v5–v4的长度为：50，而dis[3]的值为60，所以我们要更新dis[3]的值.另外，v1-v5-v6的长度为：90，而dis[5]为100，所以我们需要更新dis[5]的值。更新后的dis数组如下图:然后，继续从dis中选择未确定的顶点的值中选择一个最小的值，发现dis[3]的值是最小的，所以把v4加入到集合T中，此时集合T={v1,v3,v5,v4},然后，考虑v4的出度是否会影响我们的数组dis的值，v4有一条出度：&lt; v4,v6&gt;,然后我们发现：v1–v5–v4–v6的长度为：60，而dis[5]的值为90，所以我们要更新dis[5]的值，更新后的dis数组如下图：然后，我们使用同样原理，分别确定了v6和v2的最短路径，最后dis的数组的值如下：因此，从图中，我们可以发现v1-v2的值为：∞，代表没有路径从v1到达v2。所以我们得到的最后的结果为：123456起点 终点 最短路径 长度v1 v2 无 ∞ v3 &#123;v1,v3&#125; 10 v4 &#123;v1,v5,v4&#125; 50 v5 &#123;v1,v5&#125; 30 v6 &#123;v1，v5,v4,v6&#125; 60 代码实现利用邻接表和stl堆优化，我们可以把时间复杂度优化到O(NlogM),以下是用邻接表和stl堆优化来优化这个算法的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# include &lt;queue&gt;# include &lt;stdio.h&gt;# include &lt;string.h&gt;# include &lt;iostream&gt;# include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int M = 5e5 + 10;const int mod = 1e9 + 7;int n, m, S;int head[M], nxt[M], to[M], w[M], tot = 0;inline void add(int u, int v, int _w) &#123; ++tot; nxt[tot] = head[u]; head[u] = tot; to[tot] = v; w[tot] = _w;&#125;inline void adde(int u, int v, int _w) &#123; add(u, v, _w), add(v, u, _w);&#125;struct node&#123; int w, v; node() &#123;&#125; node(int w, int v) : w(w), v(v) &#123;&#125; friend bool operator &lt; (node a, node b) &#123; return a.w &gt; b.w; &#125;&#125;;priority_queue&lt;node&gt; q;int dis[M];bool vis[M];int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; S; for (int i=1, u, v, _w; i&lt;=m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;_w); add(u, v, _w); &#125; for (int i=1; i&lt;=n; ++i) dis[i] = 1e9, vis[i] = 0; dis[S] = 0; q.push(node(0, S)); while(!q.empty()) &#123; node tp = q.top(); q.pop(); vis[tp.v] = 1; for (int i=head[tp.v]; i; i=nxt[i]) &#123; if(dis[to[i]] &gt; dis[tp.v] + w[i]) &#123; dis[to[i]] = dis[tp.v] + w[i]; q.push(node(dis[to[i]], to[i])); &#125; &#125; &#125; for (int i=1; i&lt;=n; ++i) printf("%d ", dis[i] == 1e9 ? 2147483647 : dis[i]); cout &lt;&lt; endl; return 0;&#125; 下面这个是只利用邻接表，没有堆优化的代码，时间复杂度是O(n(n+m))，不理解算法的话先看下面这个理解一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int inf=0x3f3f3f3f;int u[10],v[10],w[10],first[10],next[10],dist[10],vis[10],n,m,k,minn;int main()&#123; scanf("%d%d",&amp;n,&amp;m); //初始化 for(int i=1; i&lt;=n; i++) first[i]=-1; //读入边 mem(dist,inf); for(int i=1; i&lt;=m; i++) &#123; scanf("%d%d%d",&amp;u[i],&amp;v[i],&amp;w[i]); next[i]=first[u[i]]; first[u[i]]=i; if(u[i]==1) dist[v[i]]=w[i];//初始化dis数组，表示1号顶点到其余各个顶点的最短路程 &#125; //初始化vis for(int i=1; i&lt;=n; i++) vis[i]=0; vis[1]=1;//标记起始点1已经被访问过 dist[1]=0; //迪杰斯特拉算法(Dijkstra)的核心内容 for(int i=1; i&lt;=n-1; i++) &#123; minn=inf; for(int j=1; j&lt;=n; j++) &#123; if(vis[j]==0&amp;&amp;dist[j]&lt;minn) &#123; minn=dist[j]; k=j; &#125; &#125; vis[k]=1; for(int l=first[k]; l!=-1; l=next[l]) &#123; if(w[l]&lt;inf) if(dist[k]+w[l]&lt;dist[v[l]]) dist[v[l]]=dist[k]+w[l]; &#125; &#125; for(int i=1; i&lt;=n; i++) printf("%d ",dist[i]); return 0;&#125; 总结迪杰斯特拉可以说是图论中求单源最短路最优的算法了(求全图最短路用弗洛里德除外)，所以同志们一定要掌握好这个算法 早日放弃SPFA和Floyd吧]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>单源最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速——卡常]]></title>
    <url>%2F2018%2F08%2F22%2F%E5%8D%A1%E5%B8%B8%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[代码中加速非常重要 废话然而我入坑了才意识到 首先是应付卡常的加速jzyzOJ 1295通过这道题我终于体会到了输入输出优化的重要性。。。其实主要就是快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[3000][3000]=&#123;&#125;;int f[3000][3000]=&#123;&#125;;int Up[3000][3000]=&#123;&#125;;int Right[3000][3000]=&#123;&#125;;int Left[3000][3000]=&#123;&#125;;inline int read()&#123; int n=1,num=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')n=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;1)+(num&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return n*num;&#125;int main()&#123; int n,m,ans=0; n=read();m=read(); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++) &#123; a[i][j]=read(); if(a[i][j]==0) &#123; Up[i+1][j]=Up[i][j]+1; Left[i][j+1]=Left[i][j]+1; &#125; &#125; for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==0) Right[i][j-1]=Right[i][j]+1; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j-1],Left[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; memset(f,0,sizeof(f)); for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j+1],Right[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; printf("%d\n",ans); return 0;&#125; 题目贴出来。。 这个是只用流输入输出的优化这道题给我这个教训以前，我曾以为这个优化很牛逼 这个是前面贴出代码的效果 其他优化日后更新 相信我]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求单源最短路——SPFA]]></title>
    <url>%2F2018%2F08%2F12%2FSPFA%2F</url>
    <content type="text"><![CDATA[SPFA好像被证明出是错的，再加上复杂度并不是很优，所以个人推荐用Dijkstra求单源最短路传送门 什么是SPFA算法呢？设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。松弛操作的原理是著名的定理：“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]&gt;dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。 和广搜bfs的区别：SPFA 在形式上和广度(宽度)优先搜索非常类似，不同的是bfs中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进(重新入队)，于是再次用来改进其它的点，这样反复迭代下去。 算法描述：1234567891011121314void spfa(s); //求单源点s到其它各顶点的最短距离 for i=1 to n do &#123; dis[i]=∞; vis[i]=false; &#125; //初始化每点到s的距离，不在队列 dis[s]=0; //将dis[源点]设为0 vis[s]=true; //源点s入队列 head=0; tail=1; q[tail]=s; //源点s入队, 头尾指针赋初值 while head&lt;tail do &#123; head+1; //队首出队 v=q[head]; //队首结点v vis[v]=false; //释放对v的标记，可以重新入队 for 每条边(v,i) //对于与队首v相连的每一条边 if (dis[i]&gt;dis[v]+a[v][i]) //如果不满足三角形性质 dis[i] = dis[v] + a[v][i] //松弛dis[i] if (vis[i]=false) &#123;tail+1; q[tail]=i; vis[i]=true;&#125; //不在队列，则加入队列 &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>单源最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的主题]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这里有个网站，推荐了几个不错的主题，还有预览click here有两个我很喜欢yiliaTranquilpeak初步打算弄成yilia然后配置yilia主题的步骤在这里click here]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo的一些操作]]></title>
    <url>%2F2018%2F08%2F01%2Fhexo%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[迁移我找到了两个网站 click here click here不过都看不懂。。最后这个详细点click here 插入媒体可以插入图片，音乐，视频click here 这个厉害click here 相册功能看起来好难弄click here]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello the cruel world!]]></title>
    <url>%2F2018%2F07%2F31%2FHello%20the%20cruel%20world!%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
