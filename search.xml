<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[求单源最短路——Dijkstra]]></title>
    <url>%2F2018%2F10%2F12%2FPrim%2F</url>
    <content type="text"><![CDATA[介绍首先，最小生成树是一副连通加权无向图中一棵权值最小的生成树。废话其次，Prim算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。这一小段粘自百度百科真的没啥可说的 算法的思路我真的不想多说，跟Dijkstra一个样Dijkstra Dijkstra记录距离的数组更新查找的是所有点到源点的距离，而Prim记录距离的数组更新查找的是所有点到 源点已经连接到的点的距离而且这两种算法每次往堆里添加的都是 所有已连接点 所能到达的所有边，并且都是每个点只能到达一次，总之，除了上面那一段讲述的 更新查找的东西不同以外，其余的一模一样。 值得一提的一点：一定一定记得用堆优化，不用堆的话时间复杂度非常吓人。 具体实现方法和示例演示就不再啰嗦了，懂Dijkstra的看完上面一段一定能懂Prim，下面只贴出代码。 代码实现细心的同学可以发现，连代码都跟Dijkstra差不了多少1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# include &lt;queue&gt;# include &lt;stdio.h&gt;# include &lt;string.h&gt;# include &lt;iostream&gt;# include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int M = 5e5 + 10;const int mod = 1e9 + 7;int n, m;int head[M], nxt[M], to[M], w[M], tot = 0;inline void add(int u, int v, int _w) &#123; ++tot; nxt[tot] = head[u]; head[u] = tot; to[tot] = v; w[tot] = _w;&#125;inline void adde(int u, int v, int _w) &#123; add(u, v, _w), add(v, u, _w);&#125;struct node &#123; int w, v; node() &#123;&#125; node(int w, int v) : w(w), v(v) &#123;&#125; friend bool operator &lt;(node a, node b) &#123; return a.w &gt; b.w; &#125;&#125;;bool vis[M];priority_queue &lt;struct node&gt; q;inline int prim() &#123; int ans = 0; while(!q.empty()) q.pop(); vis[1] = 1; for (int i=head[1]; i; i=nxt[i]) q.push(node(w[i], to[i])); for (int e=1; e&lt;n; ++e) &#123; node tp = q.top(); q.pop(); while(vis[tp.v]) &#123; tp = q.top(); q.pop(); &#125; vis[tp.v] = 1; ans += tp.w; for (int i=head[tp.v]; i; i=nxt[i]) if(!vis[to[i]]) q.push(node(w[i], to[i])); &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i=1, u, v, _w; i&lt;=m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;_w); adde(u, v, _w); &#125; cout &lt;&lt; prim(); return 0;&#125; 总结对于最小生成树来说，Prim和Kruskal都很优秀，但Prim用在稠密图（点少边多的图）有奇效，两者都很优秀，一般会一种即可，有追求的当然都要掌握，毕竟并查集也是一个重点。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%BB%84%E5%90%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[又是数论的东西。。 介绍什么是组合数呢？很简单，也别问神奇海螺了。 从n个不同元素中，任取m(m≤n)个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n)个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。 计算看起来很有用的样子，怎么求组合数呢？从n中取m个数写作C(n,m)，并且显然C(n,m)=C(n,n-m)。 算法不难，公式哪来的我也不知道，拿去用就行了。应付阶乘记得加上快速乘传送门 应用为什么每天的模拟题都要有数论啊。。。 毫无头绪，暴力都不会打，可最后还是骗了20分。。12345678910int p,q,k,n,maxx,ans;void dfs(int d,int w,int sum)&#123; if(sum==d&amp;&amp;w==n) &#123;ans++;return;&#125; if(w&gt;n) return; maxx=d+n*k; for(register int i=-k;i&lt;=maxx;++i) dfs(d,w+1,sum+i); return;&#125; 我们来思考一下正解： 我们先想一下，如果这个数列是递增的该怎么做？除去首项与末项，我们还有n-2项需要填，需要我们去挑选不同的数字，因为这个数列是递增的，所以我们只有q-p-1项去挑选。(举个栗子，比如p=3，q=9，我们只有4~8一共5个数来选)所以针对这个简化的问题，答案是 C ( q-p-1，n-2 ) 。 接着我们考虑，如果把递增改为不递减呢？上面那个问题的每一项减去前一项（题目上的k）都是大于0的，这个问题无非就是上面的问题加了一个k=0的情况，当k=0时，我们可以选择和前面相同的数，对于存在k=0的情况（不递减的所有情况除去上面递增的情况，也就是k可以=0增加的情况），至少有两个数是相等的（因为任意两数都不相等的情况属于上面递增数列的情况，而我们现在单独讨论k=0的情况）。因为一共n个数全都可以选，至少有两数相等，所以可供我们选择的数多了n-1个。因此，此时的答案是 C ( q-p+(n-1)-1 ，n-2 ) 。 然后呢，k=0的情况可供选择的数多了n-1个，我们不难发现，k每增加1，情况可供选择的数就会增加n-1个，理由同上。所以最终答案就是 C ( q-p+(k+1)*(n-1)-1 ，n-2 ) 。 如果看的不是很懂，具体参考维基的介绍隔板法，记得翻墙去看。 好，公式推出来以后，问题就解决了，直接用组合数的计算公式计算答案就行了。因为要对除法取模，所以又要用费马小定理，再加上快速幂，快速乘就可以了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int nnn=1,numm=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')nnn=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; numm=(numm&lt;&lt;1)+(numm&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return nnn*numm;&#125;const int P=998244353;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%P; xt=(xt+xt)%P; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax); ax=quick(ax,ax); bx&gt;&gt;=1; &#125; return anss;&#125;long long p,q,k,n,x1,x2,x3,ans;int main()&#123; freopen("sequence.in","r",stdin); freopen("sequence.out","w",stdout); register int t=read(); for(register int o=1;o&lt;=t;++o) &#123; p=read(),q=read(),k=read(),n=read(); x1=1,x2=1,x3=1; for(register int i=2;i&lt;=n-2;++i) x1=quick(x1,i); for(register int i=2;i&lt;=q-p+(k+1)*(n-1)-1;++i) x2=quick(x2,i); for(register int i=2;i&lt;=q-p+(k+1)*(n-1)-n+1;++i) x3=quick(x3,i); ans=quick(x2,pow(quick(x1,x3),P-2)); printf("%d\n",ans); &#125; return 0;&#125; 这道题我感觉难度还是挺大的，noip有出组合数的可能，但是应该不会出这种难度的题。但是会做这道题了，还怕noip考你组合数吗？]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[不知道为啥，总觉得数论很难，而noip2017的day1 t1给了我很大的心里阴影不管怎么样，也不能不管数论啊。。。 介绍首先，什么是卡特兰数呢Catalan数好像来自一个这样的问题一个栈的进栈序列为1,2,3，……，n，有多少个不同的出栈序列？ 我们来分析一下首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)*f(k-1)种，求和便是Catalan递归式。 还有一种分析对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。看图，其实就是问从A走到B有多少种走法（每次只能向右或向上走一个单位长度，就像对于栈只有进栈和出栈两种操作） 这个答案序列我们就把它称为Catalan数列，中文音译过来卡特兰，卡塔兰都行。 计算怎么得出卡特兰序列呢 令h(0)=1,h(1)=1，catalan数满足递推式：1C(n)= C(0)*C(n-1)+C(1)*C(n-2)+...+C(n-1)*C(0) (n&gt;=2) 不过有个更简单的式子，我一般用这个:1C(n)=C(n-1)*(4*n-2)/(n+1) 第一个递推式很容易推出来，第二个我不知道怎么推的，可能是第一个式子的简化吧，我不知道。 题目要求计算卡特兰数的时候通常要取模，这个时候就用到了费马小定理，假设模数为P(P为质数，否则要用欧拉定理)，则1C(n)=C(n-1)*(4*n-2)*(n+1)^(P-2) 这时候快速幂是必要的，快速乘可有可无快速幂传送门 应用用到某些找规律题还是很舒服的，枚举前几个数，如果是1,2,5,14,42，要是我，我会毫不犹豫地敲卡特兰数列的。今天就遇到这样一道题 100%的数据是T≤50000，n≤200000 很明显是道数论题，然后我直接就懵了，暴力都不会打，我想可能会有公式，然后我就尝试着推一推，（也是受noip2017小凯的疑惑影响才要推公式，以下是我的错误推论，怕被我误导的跳过这一点）我手推把第四项算出来是14，第五项是42，然后计算了一下第六项是146（正确的是132，我也没法检验对错啊）然后就有了下面的思路： 看着是挺对的，之后我测试了题目给的大数据，就知道离爆零不远了 咳咳回归正题其实这题的答案就是一个Catalan数列，对于要取模的数用费马小定理,再加上快速幂就行了，我把快速乘也加上了，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int nnn=1,numm=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')nnn=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; numm=(numm&lt;&lt;1)+(numm&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return nnn*numm;&#125;const int p = 1000000007;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%p; xt=(xt+xt)%p; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax)%p;//ans=ans*a%p; ax=quick(ax,ax)%p;//a=a*a%p; bx&gt;&gt;=1; &#125; return anss;&#125;long long w[200005];int main()&#123; freopen("notitle.in","r",stdin); freopen("notitle.out","w",stdout); long long xx; w[1]=1; for(register int i=2;i&lt;=200003;++i) &#123; xx=pow(i+1,p-2); w[i]=quick(w[i-1],quick((4*i-2),xx))%p; &#125; int t=read(); for(register int i=1;i&lt;=t;++i) cout&lt;&lt;w[read()]&lt;&lt;endl; return 0;&#125; 某学长以前提到过Catalan数列，当时没细讲，我觉得没有那么重要，所以就没太在意。Catalan数列还是很有用的，这道题拉了我不少分，以后再见到答案是Catalan数列的题就不会轻易放过了。。 最后献上真正的《无题》]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速——快速幂]]></title>
    <url>%2F2018%2F09%2F26%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[可能我的码风有些奇特吧。。。可我觉得挺好的呀 快速幂+快速乘 12345678910111213141516171819202122232425const int P=1000000007;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%P; xt=(xt+xt)%P; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax);//ans=ans*a%P; ax=quick(ax,ax);//a=a*a%P; bx&gt;&gt;=1; &#125; return anss;&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求单源最短路——Dijkstra]]></title>
    <url>%2F2018%2F09%2F02%2FDijkstra%2F</url>
    <content type="text"><![CDATA[介绍迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 示例演示下面我求下图，从顶点v1到其他各个顶点的最短路径首先第一步，我们先声明一个dis数组，该数组初始化的值为：我们的顶点集T的初始化为：T={v1}既然是求 v1顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离v1顶点最近是 v3顶点。当选择了 2 号顶点后，dis[2]（下标从0开始）的值就已经从“估计值”变为了“确定值”，即 v1顶点到 v3顶点的最短路程就是当前 dis[2]值。将V3加入到T中。为什么呢？因为目前离 v1顶点最近的是 v3顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 v1顶点到 v3顶点的路程进一步缩短了。因为 v1顶点到其它顶点的路程肯定没有 v1到 v3顶点短.OK，既然确定了一个顶点的最短路径，下面我们就要根据这个新入的顶点V3会有出度，发现以v3 为弧尾的有： &lt; v3,v4 &gt;,那么我们看看路径：v1–v3–v4的长度是否比v1–v4短，其实这个已经是很明显的了，因为dis[3]代表的就是v1–v4的长度为无穷大，而v1–v3–v4的长度为：10+50=60，所以更新dis[3]的值,得到如下结果：因此 dis[3]要更新为 60。这个过程有个专业术语叫做“松弛”。即 v1顶点到 v4顶点的路程即 dis[3]，通过 &lt; v3,v4&gt; 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。然后，我们又从除dis[2]和dis[0]外的其他值中寻找最小值，发现dis[4]的值最小，通过之前是解释的原理，可以知道v1到v5的最短距离就是dis[4]的值，然后，我们把v5加入到集合T中，然后，考虑v5的出度是否会影响我们的数组dis的值，v5有两条出度：&lt; v5,v4&gt;和 &lt; v5,v6&gt;,然后我们发现：v1–v5–v4的长度为：50，而dis[3]的值为60，所以我们要更新dis[3]的值.另外，v1-v5-v6的长度为：90，而dis[5]为100，所以我们需要更新dis[5]的值。更新后的dis数组如下图:然后，继续从dis中选择未确定的顶点的值中选择一个最小的值，发现dis[3]的值是最小的，所以把v4加入到集合T中，此时集合T={v1,v3,v5,v4},然后，考虑v4的出度是否会影响我们的数组dis的值，v4有一条出度：&lt; v4,v6&gt;,然后我们发现：v1–v5–v4–v6的长度为：60，而dis[5]的值为90，所以我们要更新dis[5]的值，更新后的dis数组如下图：然后，我们使用同样原理，分别确定了v6和v2的最短路径，最后dis的数组的值如下：因此，从图中，我们可以发现v1-v2的值为：∞，代表没有路径从v1到达v2。所以我们得到的最后的结果为：123456起点 终点 最短路径 长度v1 v2 无 ∞ v3 &#123;v1,v3&#125; 10 v4 &#123;v1,v5,v4&#125; 50 v5 &#123;v1,v5&#125; 30 v6 &#123;v1，v5,v4,v6&#125; 60 代码实现利用邻接表和stl堆优化，我们可以把时间复杂度优化到O(NlogM),以下是用邻接表和stl堆优化来优化这个算法的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# include &lt;queue&gt;# include &lt;stdio.h&gt;# include &lt;string.h&gt;# include &lt;iostream&gt;# include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int M = 5e5 + 10;const int mod = 1e9 + 7;int n, m, S;int head[M], nxt[M], to[M], w[M], tot = 0;inline void add(int u, int v, int _w) &#123; ++tot; nxt[tot] = head[u]; head[u] = tot; to[tot] = v; w[tot] = _w;&#125;inline void adde(int u, int v, int _w) &#123; add(u, v, _w), add(v, u, _w);&#125;struct node&#123; int w, v; node() &#123;&#125; node(int w, int v) : w(w), v(v) &#123;&#125; friend bool operator &lt; (node a, node b) &#123; return a.w &gt; b.w; &#125;&#125;;priority_queue&lt;node&gt; q;int dis[M];bool vis[M];int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; S; for (int i=1, u, v, _w; i&lt;=m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;_w); add(u, v, _w); &#125; for (int i=1; i&lt;=n; ++i) dis[i] = 1e9, vis[i] = 0; dis[S] = 0; q.push(node(0, S)); while(!q.empty()) &#123; node tp = q.top(); q.pop(); vis[tp.v] = 1; for (int i=head[tp.v]; i; i=nxt[i]) &#123; if(dis[to[i]] &gt; dis[tp.v] + w[i]) &#123; dis[to[i]] = dis[tp.v] + w[i]; q.push(node(dis[to[i]], to[i])); &#125; &#125; &#125; for (int i=1; i&lt;=n; ++i) printf("%d ", dis[i] == 1e9 ? 2147483647 : dis[i]); cout &lt;&lt; endl; return 0;&#125; 下面这个是只利用邻接表，没有堆优化的代码，时间复杂度是O(n(n+m))，不理解算法的话先看下面这个理解一下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int inf=0x3f3f3f3f;int u[10],v[10],w[10],first[10],next[10],dist[10],vis[10],n,m,k,minn;int main()&#123; scanf("%d%d",&amp;n,&amp;m); //初始化 for(int i=1; i&lt;=n; i++) first[i]=-1; //读入边 mem(dist,inf); for(int i=1; i&lt;=m; i++) &#123; scanf("%d%d%d",&amp;u[i],&amp;v[i],&amp;w[i]); next[i]=first[u[i]]; first[u[i]]=i; if(u[i]==1) dist[v[i]]=w[i];//初始化dis数组，表示1号顶点到其余各个顶点的最短路程 &#125; //初始化vis for(int i=1; i&lt;=n; i++) vis[i]=0; vis[1]=1;//标记起始点1已经被访问过 dist[1]=0; //迪杰斯特拉算法(Dijkstra)的核心内容 for(int i=1; i&lt;=n-1; i++) &#123; minn=inf; for(int j=1; j&lt;=n; j++) &#123; if(vis[j]==0&amp;&amp;dist[j]&lt;minn) &#123; minn=dist[j]; k=j; &#125; &#125; vis[k]=1; for(int l=first[k]; l!=-1; l=next[l]) &#123; if(w[l]&lt;inf) if(dist[k]+w[l]&lt;dist[v[l]]) dist[v[l]]=dist[k]+w[l]; &#125; &#125; for(int i=1; i&lt;=n; i++) printf("%d ",dist[i]); return 0;&#125; 总结迪杰斯特拉可以说是图论中求单源最短路最优的算法了(求全图最短路用弗洛里德除外)，所以同志们一定要掌握好这个算法 早日放弃SPFA和Floyd吧]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>单源最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速——卡常]]></title>
    <url>%2F2018%2F08%2F22%2F%E5%8D%A1%E5%B8%B8%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[代码中加速非常重要 废话然而我入坑了才意识到 首先是应付卡常的加速jzyzOJ 1295通过这道题我终于体会到了输入输出优化的重要性。。。其实主要就是快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[3000][3000]=&#123;&#125;;int f[3000][3000]=&#123;&#125;;int Up[3000][3000]=&#123;&#125;;int Right[3000][3000]=&#123;&#125;;int Left[3000][3000]=&#123;&#125;;inline int read()&#123; int n=1,num=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')n=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;1)+(num&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return n*num;&#125;int main()&#123; int n,m,ans=0; n=read();m=read(); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++) &#123; a[i][j]=read(); if(a[i][j]==0) &#123; Up[i+1][j]=Up[i][j]+1; Left[i][j+1]=Left[i][j]+1; &#125; &#125; for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==0) Right[i][j-1]=Right[i][j]+1; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j-1],Left[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; memset(f,0,sizeof(f)); for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j+1],Right[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; printf("%d\n",ans); return 0;&#125; 题目贴出来。。 这个是只用流输入输出的优化这道题给我这个教训以前，我曾以为这个优化很牛逼 这个是前面贴出代码的效果 其他优化日后更新 相信我]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求单源最短路——SPFA]]></title>
    <url>%2F2018%2F08%2F12%2FSPFA%2F</url>
    <content type="text"><![CDATA[SPFA好像被证明出是错的，再加上复杂度并不是很优，所以个人推荐用Dijkstra求单源最短路传送门 什么是SPFA算法呢？设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。松弛操作的原理是著名的定理：“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]&gt;dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。 和广搜bfs的区别：SPFA 在形式上和广度(宽度)优先搜索非常类似，不同的是bfs中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进(重新入队)，于是再次用来改进其它的点，这样反复迭代下去。 算法描述：1234567891011121314void spfa(s); //求单源点s到其它各顶点的最短距离 for i=1 to n do &#123; dis[i]=∞; vis[i]=false; &#125; //初始化每点到s的距离，不在队列 dis[s]=0; //将dis[源点]设为0 vis[s]=true; //源点s入队列 head=0; tail=1; q[tail]=s; //源点s入队, 头尾指针赋初值 while head&lt;tail do &#123; head+1; //队首出队 v=q[head]; //队首结点v vis[v]=false; //释放对v的标记，可以重新入队 for 每条边(v,i) //对于与队首v相连的每一条边 if (dis[i]&gt;dis[v]+a[v][i]) //如果不满足三角形性质 dis[i] = dis[v] + a[v][i] //松弛dis[i] if (vis[i]=false) &#123;tail+1; q[tail]=i; vis[i]=true;&#125; //不在队列，则加入队列 &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
        <tag>单源最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的主题]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这里有个网站，推荐了几个不错的主题，还有预览click here有两个我很喜欢yiliaTranquilpeak初步打算弄成yilia然后配置yilia主题的步骤在这里click here]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo的一些操作]]></title>
    <url>%2F2018%2F08%2F01%2Fhexo%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[迁移我找到了两个网站 click here click here不过都看不懂。。最后这个详细点click here 插入媒体可以插入图片，音乐，视频click here 这个厉害click here 相册功能看起来好难弄click here]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello the cruel world!]]></title>
    <url>%2F2018%2F07%2F31%2FHello%20the%20cruel%20world!%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
