<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[实用的网站]]></title>
    <url>%2F2018%2F10%2F17%2F%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[这里盘点一些博主收集的几个很不错的网站。对程序员来说真的能省掉许多不必要的功夫。我真的不是在打广告，没有任何人给我钱的。 图论构图传送门PS:这是个歪果网站，所以翻墙食用更佳。 操作简单，对于图论画图这方面非常非常非常好用。也挺好玩的预览: 数论公式&amp;&amp;函数图像传送门PS:这也是个歪果网站，所以翻墙食用更佳。 这个网站是真的强大。对于一个函数呢，它能给你变形和它的几组解，还能把图像给你画出来。对于一个数列呢，它能往后给出好多项，还能把通项公式告诉你。除了这些，还会给你一大堆你看不懂的东西。好吧，是我看不懂。也是好玩又好用。 预览:输入(x^2+y^2-1)^3-(x^2)*(y^3)=0 输入Catalan数的前几项 下面还有 其它目前博主手里也就这些好玩好用的网站。真的没有更多了。以后再发现其它好玩好用的网站呢，我一定会更新的。所以，记得时不时来这里看一看哦。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学期望]]></title>
    <url>%2F2018%2F10%2F15%2F%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%9B%2F</url>
    <content type="text"><![CDATA[不知道这算不算数论的东西，不过我个人觉得挺简单的 介绍什么是数学期望呢？就是所有结果的概率乘该结果的值的总和。——沃·兹基硕德 例题有种神奇的东西叫做期望DP，用起来很简单，理解起来也很简单，不过对于下面这道例题，我更喜欢用一种更简单的方法。100%的数据范围是n&lt;=1e7 看完题目有什么想法呢？我要先吐槽一下。题目是求一个期望值，所以答案一定是个小数，对小数取模要用到乘法逆元，所以结果是一个巨大无比的数，而只有n=2对应的答案是很小的，综上所述，样例没有什么用，也就是让大家理解题意而已了。 其实不是的，样例非常非常非常有用。 我先说说我的算法吧。我这种写法对于这个题要有一定的逆向思维，我先正着讲，让你们理解一下。你们看完以后可以思考你们自己用这种方法写的话，思路的先后顺序是个什么样。 首先要弄懂样例的意思，n=2时答案的2是哪来的呢？123456第一次有0.5的概率跳到1，共跳了1次，所以值为0.5*1第二次有0.25的概率跳到1，共跳了2次，所以值为0.25*2第三次有0.5的概率跳到1，共跳了3次，所以值为0.125*3...所以n=2时，答案是0.5+0.25*2+0.125*3+.....一直加下去，答案就无限接近2 对于这个样例，你原本就在2这个位置，那么我问大家一个问题：如果你是跳了1步到的2这个位置，那么答案是多少？如果你是跳了2步到的2这个位置，那么答案是多少？如果你是跳了x步到的2这个位置，那么答案是多少？很显然，答案是2+x。举个栗子吧，跳1步到2的时候，答案是0.5×2+0.25×3+0.125×4+….. ，比原来直接在2的答案多了0.5+0.25+0.125+…. ，多加的值无限趋近于1，所以跳1步到达2的答案就是3。为了验证这个结论，我还打了暴力试了一下呢。 我们再手推一下n=3的答案，因为n=2具有一定的迷惑性（非A则B，并且概率相同，不具有普遍性）。123456789101112第一次有1/3的概率跳到1，共跳了1次，所以值为1/3*1 有1/3的概率跳到2，共跳了1次，所以值为1/3*(2+1) (这里就用到了刚刚我们推的结论， 跳了一步到2的答案为2+1，而一步跳到2的概率为1/3)第二次有（1/3）^2的概率跳到1，共跳了2次，所以值为(1/9)*2 有（1/3）^2的概率跳到2，共跳了2次，所以值为(1/9)*(2+2)第三次有（1/3）^3的概率跳到1，共跳了3次，所以值为(1/27)*3 有（1/3）^3的概率跳到2，共跳了3次，所以值为(1/27)*(2+3)...所以n=3时，答案是 1/3*1 +1/3*(2+1) +(1/9)*2 +(1/9)*(2+2)+(1/27)*3+(1/27)*(2+3)+.....化简一下： 1/3*(1+3) +(1/3)^2*(2+4) +(1/3)^3*(3+5) +.....一直加下去，答案就无限接近2.5（先不计算取模） 现在大家应该明白了这种算法的真正思路，然后我们来推公式。想想我们有什么条件，怕大家不懂，稍微啰嗦了一下，其实很简单。共有n扇门。因为上面的加法是一直加的，因为他可以一直跳下去，所以要算出准确答案，我们就设他跳了s次，s趋近于无穷大。（我也不知道怎么描述s，不明白s的含义的没关系，看到后面的公式就明白了，我只是想利用s表达求和式子的最后一项）设答案为S。（相当于数列的前n项和，高中数学知识）设t=1+3+3.5+…+S[n-1]。（这是一个递推的思想，因为计算第n项要用到前面推出的1~n-1的答案，我们先把这些答案都+1,不加也可以，不加的话后面的公式稍微变一下就行了，一样的，我们先把这些前面推出的答案都+1）那么公式来了：12345678910111213S=1/n*t +(1/n)^2*(t+n-1) +(1/n)^3*[t+2*(n-1)]+.... +(1/n)^s*(t+(s-1)*(n-1))这里用到了数列求和的错位相减法：标记上面等式为①，等号两边同时乘(1/n)得到②：(1/n)*S=(1/n)^2*t +(1/n)^3*(t+n-1) +(1/n)^4*[t+2*(n-1)]+...+(1/n)^(s+1)*[t+(s-1)*(n-1)]①-②再化简得：(n-1)/n *S=(1/n)*t+ (n-1)*[(1/n)^2+(1/n)^3+...(1/n)^s] -(1/n)^(s+1) *[t+(s-1)(n-1)]第一个中括号里是一个等比数列，对这个等比数列进行就和来化简：这个中括号里的值的分子=(1/n)^2 *(1-(1-n)^s)，因为s趋近于无穷大，所以(1-n)^s趋近于0，所以(1-(1-n)^s)趋近于1，所以分子就=(1/n)^2这个值的分母是1- 1/n，化简一下这个分数，最后中括号里的值是 1/ n(n-1)再回到整个式子：(n-1)/n *S=(1/n)*t + 1/ n(n-1) -(1/n)^(s+1) *[t+(s-1)(n-1)]再看一下减号后面的一堆内容，因为s趋近于正无穷，所以s+1也是正无穷，所以(1/n)^(s+1)=0，然后减号后面的一堆东西就没了。所以整个式子化简成了：(n-1)/n *S=(1/n)*t + 1/ n(n-1)再化简：S=(t+1)/(n-1)公式就成功推出来了。 所以样例给的2可能就是给我们初始值让我们递推的。代码实现就很简单了，从3开始计算，一直到n，每次更新t的值，对于模运算呢还要再加上线性求逆元，用快速幂的话只能拿70分。线性求逆元传送门 下面贴上我的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;cstdio&gt;#include&lt;ctime&gt;using namespace std;inline int read()&#123; int nnn=1,numm=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')nnn=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; numm=(numm&lt;&lt;1)+(numm&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return nnn*numm;&#125;const int P=1000000007;long long n,ans,k=4,t,w,x,xx;long long inv[10000005];inline void init_inv()&#123; inv[1]=1; for(register int i=2;i&lt;=n;++i) inv[i]=(P-P/i)*inv[P%i]%P;&#125;int main()&#123; freopen("life.in","r",stdin); freopen("life.out","w",stdout); n=read(); init_inv(); if(n==1)&#123;cout&lt;&lt;0;return 0;&#125; if(n==2)&#123;cout&lt;&lt;2;return 0;&#125; for(register int i=3;i&lt;=n;++i) &#123; x=(k+1)*inv[i-1]%P; k+=x+1; k%=P; if(i==n) ans=x; &#125; printf("%lld\n",ans); return 0;&#125; 其实代码刚敲好我的心里是没底的，因为推数列的计算量不小，如果我哪一步稍有差错那么整道题就全WA了，因为我也不喜欢检查，这样容易晕，所以我每一步计算都要确认好几遍。直到mdb同学推出了一个跟我不同的公式，（其实跟我的一样，形式不同罢了）跟我对答案发现结果一样的时候，我感觉才稳了一点。 其实这道题的正解是期望DP，也不难，不过我更喜欢我这一种 总结我的算法讲完了，代码也贴出来了，我前面有说过，我是顺着讲的，如果没有真正理解，你自己写是写不出来的，所以大家要试着理解我为什么要先算这些东西。其实也没什么，先弄懂样例（为什么n=2时，答案为2），类比具有普遍特征的数（手推n=3的情况），然后意识到要用前面的答案（有概率跳到一个点再从这个点到1），然后研究怎么用前面的答案（第x步跳到某个点，那就是x+该点的期望值），接着推公式，然后化简，就这样就搞定了。 对于数学期望的题，基本上全都可以用期望DP来写，但是有不少题都可以推公式，而且能推公式的题基本都跟这道题差不多，知识点只需要高中关于数列的知识就行了（逆元无论什么算法都是必要的），那么对于不擅长DP、不喜欢DP的同学呢，这种方法是你很好的选择。但是有的数学期望题不能推公式，特别是那种输入不是简简单单的一个数，而是某个场景的数据的题，就比如NOIP2016的换教室，像那种题一看就知道推公式不可行。我不敢保证每道输入简单的数学期望题都可以推公式，但是遇到那种数学期望题不妨试着推一推，都是一些数列的东西，推着难度也不大，思路清晰是必要的，而思路清晰以后推公式也用不了多长时间，对吧？]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>例题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树——Prim]]></title>
    <url>%2F2018%2F10%2F12%2FPrim%2F</url>
    <content type="text"><![CDATA[介绍首先，最小生成树是一副连通加权无向图中一棵权值最小的生成树。废话其次，Prim算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。这一小段粘自百度百科真的没啥可说的 算法的思路我真的不想多说，跟Dijkstra一个样DijkstraDijkstra记录距离的数组更新查找的是所有点到源点的距离，而Prim记录距离的数组更新查找的是所有点到 源点已经连接到的点的距离.而且这两种算法每次往堆里添加的都是 所有已连接点 所能到达的所有边，并且都是每个点只能到达一次，总之，除了上面那一段讲述的 更新查找的东西不同以外，其余的一模一样。 值得一提的一点：一定一定记得用堆优化，不用堆的话时间复杂度非常吓人。 下面给出来一个步骤演示 具体实现方法就不再啰嗦了，懂Dijkstra的看完上面一段一定能懂Prim，下面只贴出代码。 代码实现细心的同学可以发现，连代码都跟Dijkstra差不了多少1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# include &lt;queue&gt;# include &lt;stdio.h&gt;# include &lt;string.h&gt;# include &lt;iostream&gt;# include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef unsigned long long ull;typedef long double ld;const int M = 5e5 + 10;const int mod = 1e9 + 7;int n, m;int head[M], nxt[M], to[M], w[M], tot = 0;inline void add(int u, int v, int _w) &#123; ++tot; nxt[tot] = head[u]; head[u] = tot; to[tot] = v; w[tot] = _w;&#125;inline void adde(int u, int v, int _w) &#123; add(u, v, _w), add(v, u, _w);&#125;struct node &#123; int w, v; node() &#123;&#125; node(int w, int v) : w(w), v(v) &#123;&#125; friend bool operator &lt;(node a, node b) &#123; return a.w &gt; b.w; &#125;&#125;;bool vis[M];priority_queue &lt;struct node&gt; q;inline int prim() &#123; int ans = 0; while(!q.empty()) q.pop(); vis[1] = 1; for (int i=head[1]; i; i=nxt[i]) q.push(node(w[i], to[i])); for (int e=1; e&lt;n; ++e) &#123; node tp = q.top(); q.pop(); while(vis[tp.v]) &#123; tp = q.top(); q.pop(); &#125; vis[tp.v] = 1; ans += tp.w; for (int i=head[tp.v]; i; i=nxt[i]) if(!vis[to[i]]) q.push(node(w[i], to[i])); &#125; return ans;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i=1, u, v, _w; i&lt;=m; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;_w); adde(u, v, _w); &#125; cout &lt;&lt; prim(); return 0;&#125; 总结对于最小生成树来说，Prim和Kruskal都很优秀，但Prim用在稠密图（点少边多的图）有奇效，两者都很优秀，一般会一种即可，有追求的当然都要掌握，毕竟并查集也是一个重点。]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合数]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%BB%84%E5%90%88%E6%95%B0%2F</url>
    <content type="text"><![CDATA[又是数论的东西。。 介绍什么是组合数呢？很简单，也别问神奇海螺了。 从n个不同元素中，任取m(m≤n)个元素并成一组，叫做从n个不同元素中取出m个元素的一个组合；从n个不同元素中取出m(m≤n)个元素的所有组合的个数，叫做从n个不同元素中取出m个元素的组合数。 计算看起来很有用的样子，怎么求组合数呢？从n中取m个数写作C(n,m)，并且显然C(n,m)=C(n,n-m)。 算法不难，公式哪来的我也不知道，拿去用就行了。应付阶乘记得加上快速乘传送门 应用为什么每天的模拟题都要有数论啊。。。 毫无头绪，暴力都不会打，可最后还是骗了20分。。12345678910int p,q,k,n,maxx,ans;void dfs(int d,int w,int sum)&#123; if(sum==d&amp;&amp;w==n) &#123;ans++;return;&#125; if(w&gt;n) return; maxx=d+n*k; for(register int i=-k;i&lt;=maxx;++i) dfs(d,w+1,sum+i); return;&#125; 我们来思考一下正解： 我们先想一下，如果这个数列是递增的该怎么做？除去首项与末项，我们还有n-2项需要填，需要我们去挑选不同的数字，因为这个数列是递增的，所以我们只有q-p-1项去挑选。(举个栗子，比如p=3，q=9，我们只有4~8一共5个数来选)所以针对这个简化的问题，答案是 C ( q-p-1，n-2 ) 。 接着我们考虑，如果把递增改为不递减呢？上面那个问题的每一项减去前一项（题目上的k）都是大于0的，这个问题无非就是上面的问题加了一个k=0的情况，当k=0时，我们可以选择和前面相同的数，对于存在k=0的情况（不递减的所有情况除去上面递增的情况，也就是k可以=0增加的情况），至少有两个数是相等的（因为任意两数都不相等的情况属于上面递增数列的情况，而我们现在单独讨论k=0的情况）。因为一共n个数全都可以选，至少有两数相等，所以可供我们选择的数多了n-1个。因此，此时的答案是 C ( q-p+(n-1)-1 ，n-2 ) 。 然后呢，k=0的情况可供选择的数多了n-1个，我们不难发现，k每增加1，情况可供选择的数就会增加n-1个，理由同上。所以最终答案就是 C ( q-p+(k+1)*(n-1)-1 ，n-2 ) 。 如果看的不是很懂，具体参考维基的介绍隔板法，记得翻墙去看。 好，公式推出来以后，问题就解决了，直接用组合数的计算公式计算答案就行了。因为要对除法取模，所以又要用费马小定理，再加上快速幂，快速乘就可以了。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int nnn=1,numm=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')nnn=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; numm=(numm&lt;&lt;1)+(numm&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return nnn*numm;&#125;const int P=998244353;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%P; xt=(xt+xt)%P; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax); ax=quick(ax,ax); bx&gt;&gt;=1; &#125; return anss;&#125;long long p,q,k,n,x1,x2,x3,ans;int main()&#123; freopen("sequence.in","r",stdin); freopen("sequence.out","w",stdout); register int t=read(); for(register int o=1;o&lt;=t;++o) &#123; p=read(),q=read(),k=read(),n=read(); x1=1,x2=1,x3=1; for(register int i=2;i&lt;=n-2;++i) x1=quick(x1,i); for(register int i=2;i&lt;=q-p+(k+1)*(n-1)-1;++i) x2=quick(x2,i); for(register int i=2;i&lt;=q-p+(k+1)*(n-1)-n+1;++i) x3=quick(x3,i); ans=quick(x2,pow(quick(x1,x3),P-2)); printf("%d\n",ans); &#125; return 0;&#125; 这道题我感觉难度还是挺大的，noip有出组合数的可能，但是应该不会出这种难度的题。但是会做这道题了，还怕noip考你组合数吗？]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>例题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡特兰数]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%8D%A1%E7%89%B9%E5%85%B0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[不知道为啥，总觉得数论很难，而noip2017的day1 t1给了我很大的心里阴影不管怎么样，也不能不管数论啊。。。 介绍首先，什么是卡特兰数呢Catalan数好像来自一个这样的问题一个栈的进栈序列为1,2,3，……，n，有多少个不同的出栈序列？ 我们来分析一下首先，我们设f（n）=序列个数为n的出栈序列种数。（我们假定，最后出栈的元素为k，显然，k取不同值时的情况是相互独立的，也就是求出每种k最后出栈的情况数后可用加法原则，由于k最后出栈，因此，在k入栈之前，比k小的值均出栈，此处情况有f(k-1)种，而之后比k大的值入栈，且都在k之前出栈，因此有f(n-k)种方式，由于比k小和比k大的值入栈出栈情况是相互独立的，此处可用乘法原则，f(n-k)*f(k-1)种，求和便是Catalan递归式。 还有一种分析对于每一个数来说，必须进栈一次、出栈一次。我们把进栈设为状态‘1’，出栈设为状态‘0’。n个数的所有状态对应n个1和n个0组成的2n位二进制数。由于等待入栈的操作数按照1‥n的顺序排列、入栈的操作数b大于等于出栈的操作数a(a≤b)，因此输出序列的总数目=由左而右扫描由n个1和n个0组成的2n位二进制数，1的累计数不小于0的累计数的方案种数。在2n位二进制数中填入n个1的方案数为c(2n,n),不填1的其余n位自动填0。从中减去不符合要求（由左而右扫描，0的累计数大于1的累计数）的方案数即为所求。看图，其实就是问从A走到B有多少种走法（每次只能向右或向上走一个单位长度，就像对于栈只有进栈和出栈两种操作） 这个答案序列我们就把它称为Catalan数列，中文音译过来卡特兰，卡塔兰都行。 计算怎么得出卡特兰序列呢 令h(0)=1,h(1)=1，catalan数满足递推式：1C(n)= C(0)*C(n-1)+C(1)*C(n-2)+...+C(n-1)*C(0) (n&gt;=2) 不过有个更简单的式子，我一般用这个:1C(n)=C(n-1)*(4*n-2)/(n+1) 第一个递推式很容易推出来，第二个我不知道怎么推的，可能是第一个式子的简化吧，我不知道。 题目要求计算卡特兰数的时候通常要取模，这个时候就用到了费马小定理，假设模数为P(P为质数，否则要用欧拉定理)，则1C(n)=C(n-1)*(4*n-2)*(n+1)^(P-2) 上面的求法快速幂是必要的。求逆元的方法有很多，在这里推荐一个线性求逆元，这样就不用快速幂了。快速幂与线性求逆元传送门 应用用到某些找规律题还是很舒服的，枚举前几个数，如果是1,2,5,14,42，要是我，我会毫不犹豫地敲卡特兰数列的。今天就遇到这样一道题 100%的数据是T≤50000，n≤200000 很明显是道数论题，然后我直接就懵了，暴力都不会打，我想可能会有公式，然后我就尝试着推一推，（也是受noip2017小凯的疑惑影响才要推公式，以下是我的错误推论，怕被我误导的跳过这一点）我手推把第四项算出来是14，第五项是42，然后计算了一下第六项是146（正确的是132，我也没法检验对错啊）然后就有了下面的思路： 看着是挺对的，之后我测试了题目给的大数据，就知道离爆零不远了 咳咳回归正题其实这题的答案就是一个Catalan数列，对于要取模的数用费马小定理,再加上快速幂就行了，我把快速乘也加上了，其实不加快速乘会更快。代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;inline int read()&#123; int nnn=1,numm=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')nnn=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; numm=(numm&lt;&lt;1)+(numm&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return nnn*numm;&#125;const int p = 1000000007;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%p; xt=(xt+xt)%p; yt&gt;&gt;=1; &#125; return summ;&#125;long long pow(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) anss=quick(anss,ax)%p;//ans=ans*a%p; ax=quick(ax,ax)%p;//a=a*a%p; bx&gt;&gt;=1; &#125; return anss;&#125;long long w[200005];int main()&#123; freopen("notitle.in","r",stdin); freopen("notitle.out","w",stdout); long long xx; w[1]=1; for(register int i=2;i&lt;=200003;++i) &#123; xx=pow(i+1,p-2); w[i]=quick(w[i-1],quick((4*i-2),xx))%p; &#125; int t=read(); for(register int i=1;i&lt;=t;++i) cout&lt;&lt;w[read()]&lt;&lt;endl; return 0;&#125; 某学长以前提到过Catalan数列，当时没细讲，我觉得没有那么重要，所以就没太在意。Catalan数列还是很有用的，这道题拉了我不少分，以后再见到答案是Catalan数列的题就不会轻易放过了。。 最后献上真正的《无题》]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>数论</tag>
        <tag>例题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速——计算]]></title>
    <url>%2F2018%2F09%2F26%2F%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[可能我的码风有些奇特吧。。。可我觉得挺好的呀 快速幂注意快速幂的函数名最好不要取pow，有时会撞上stl内置的pow，然后你的程序就炸了。1234567891011121314const int P=1000000007;long long poww(long long ax,long long bx)&#123; long long anss=1; while(bx) &#123; if(bx&amp;1) ans=ans*a%P; a=a*a%P; bx&gt;&gt;=1; &#125; return anss;&#125; 快速乘为什么叫它快速乘呢？因为它是由快速幂推出来的，只把快速幂的乘号全换成加号，计数器的初始值改为0就是快速乘了，所以，快速乘其实一点也不快速，千万千万不要被它的名字给迷惑了，当数据会爆long long的时候才用的到。12345678910111213const int P=1000000007;long long quick(long long xt,long long yt)&#123; long long summ=0; while(yt) &#123; if(yt&amp;1) summ=(summ+xt)%P; xt=(xt+xt)%P; yt&gt;&gt;=1; &#125; return summ;&#125; 线性求逆元O（n）的时间求出1~n 在mod P意义下的逆元，用的是线性递推。强烈推荐用这个方法求逆元。1inv[i]=(P- P/i)*inv[P%i] %P; 证明：123456789设 x=p%a, y=p/a;（y就是p/a的商,x就是p/a后的余数）于是： x+ y*a=P;等式两边同时对p取余:（x + y*a）%P=0;去括号并移项：x%P = - y*a %P;将a移至左边: inv[a]*x %P= - y%P; inv[a]*x %P= (-y+p)% P;将x移至右边: inv[a]=(P-y)*inv(x) % P;将证明开始设的x,y值代入上面式子中,则有：inv[a]=(P- P/a)*inv[P%a] %P;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路——Dijkstra]]></title>
    <url>%2F2018%2F09%2F02%2FDijkstra%2F</url>
    <content type="text"><![CDATA[介绍迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 示例演示下面我求下图，从顶点v1到其他各个顶点的最短路径首先第一步，我们先声明一个dis数组，该数组初始化的值为：我们的顶点集T的初始化为：T={v1}既然是求 v1顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离v1顶点最近是 v3顶点。当选择了 2 号顶点后，dis[2]（下标从0开始）的值就已经从“估计值”变为了“确定值”，即 v1顶点到 v3顶点的最短路程就是当前 dis[2]值。将V3加入到T中。为什么呢？因为目前离 v1顶点最近的是 v3顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 v1顶点到 v3顶点的路程进一步缩短了。因为 v1顶点到其它顶点的路程肯定没有 v1到 v3顶点短.OK，既然确定了一个顶点的最短路径，下面我们就要根据这个新入的顶点V3会有出度，发现以v3 为弧尾的有： &lt; v3,v4 &gt;,那么我们看看路径：v1–v3–v4的长度是否比v1–v4短，其实这个已经是很明显的了，因为dis[3]代表的就是v1–v4的长度为无穷大，而v1–v3–v4的长度为：10+50=60，所以更新dis[3]的值,得到如下结果：因此 dis[3]要更新为 60。这个过程有个专业术语叫做“松弛”。即 v1顶点到 v4顶点的路程即 dis[3]，通过 &lt; v3,v4&gt; 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。然后，我们又从除dis[2]和dis[0]外的其他值中寻找最小值，发现dis[4]的值最小，通过之前是解释的原理，可以知道v1到v5的最短距离就是dis[4]的值，然后，我们把v5加入到集合T中，然后，考虑v5的出度是否会影响我们的数组dis的值，v5有两条出度：&lt; v5,v4&gt;和 &lt; v5,v6&gt;,然后我们发现：v1–v5–v4的长度为：50，而dis[3]的值为60，所以我们要更新dis[3]的值.另外，v1-v5-v6的长度为：90，而dis[5]为100，所以我们需要更新dis[5]的值。更新后的dis数组如下图:然后，继续从dis中选择未确定的顶点的值中选择一个最小的值，发现dis[3]的值是最小的，所以把v4加入到集合T中，此时集合T={v1,v3,v5,v4},然后，考虑v4的出度是否会影响我们的数组dis的值，v4有一条出度：&lt; v4,v6&gt;,然后我们发现：v1–v5–v4–v6的长度为：60，而dis[5]的值为90，所以我们要更新dis[5]的值，更新后的dis数组如下图：然后，我们使用同样原理，分别确定了v6和v2的最短路径，最后dis的数组的值如下：因此，从图中，我们可以发现v1-v2的值为：∞，代表没有路径从v1到达v2。所以我们得到的最后的结果为：123456起点 终点 最短路径 长度v1 v2 无 ∞ v3 &#123;v1,v3&#125; 10 v4 &#123;v1,v5,v4&#125; 50 v5 &#123;v1,v5&#125; 30 v6 &#123;v1，v5,v4,v6&#125; 60 代码实现利用邻接表和stl堆优化，我们可以把时间复杂度优化到O(NlogM),以下是用邻接表和堆优化来优化这个算法的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;#include&lt;queue&gt;using namespace std;const int M=5e5+5;int head[M],nxt[M],to[M],v[M],dis[M];struct node&#123; int d,k; node(int d,int k) : d(d) , k(k) &#123;&#125; friend bool operator &lt; (node a,node b) &#123; return a.d &gt; b.d; &#125;&#125;;priority_queue&lt;node&gt; q;int main()&#123; register int n,m,S,x,y,z,tot=0; scanf("%d%d%d",&amp;n,&amp;m,&amp;S); for(int i=1;i&lt;=m;++i) &#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ++tot; nxt[tot]=head[x],head[x]=tot,to[tot]=y,v[tot]=z; &#125; for(int i=1;i&lt;=n;++i) dis[i]=1e9; dis[S]=0; q.push(node(0,S)); while(!q.empty()) &#123; node t=q.top();q.pop(); for(int i=head[t.k];i;i=nxt[i]) &#123; if(dis[to[i]]&gt;dis[t.k]+v[i]) &#123; dis[to[i]]=dis[t.k]+v[i]; q.push(node(dis[to[i]],to[i])); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) printf("%d ",dis[i]==1e9 ? -1 : dis[i]); printf("\n"); return 0;&#125; 总结迪杰斯特拉可以说是图论中求单源最短路最优的算法了(求全图最短路用弗洛里德除外)，所以同志们一定要掌握好这个算法。早日放弃SPFA和Floyd吧]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加速——卡常]]></title>
    <url>%2F2018%2F08%2F22%2F%E5%8D%A1%E5%B8%B8%E5%8A%A0%E9%80%9F%2F</url>
    <content type="text"><![CDATA[代码中加速非常重要 废话然而我入坑了才意识到 首先是应付卡常的加速jzyzOJ 1295通过这道题我终于体会到了输入输出优化的重要性。。。其实主要就是快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[3000][3000]=&#123;&#125;;int f[3000][3000]=&#123;&#125;;int Up[3000][3000]=&#123;&#125;;int Right[3000][3000]=&#123;&#125;;int Left[3000][3000]=&#123;&#125;;inline int read()&#123; int n=1,num=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')n=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;1)+(num&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return n*num;&#125;int main()&#123; int n,m,ans=0; n=read();m=read(); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++) &#123; a[i][j]=read(); if(a[i][j]==0) &#123; Up[i+1][j]=Up[i][j]+1; Left[i][j+1]=Left[i][j]+1; &#125; &#125; for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==0) Right[i][j-1]=Right[i][j]+1; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j-1],Left[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; memset(f,0,sizeof(f)); for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j+1],Right[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; printf("%d\n",ans); return 0;&#125; 题目贴出来。。 这个是只用流输入输出的优化这道题给我这个教训以前，我曾以为这个优化很牛逼 这个是前面贴出代码的效果 其他优化日后更新 相信我]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路——SPFA]]></title>
    <url>%2F2018%2F08%2F12%2FSPFA%2F</url>
    <content type="text"><![CDATA[SPFA的复杂度好像被证明出是错的，所以个人强烈推荐用Dijkstra求单源最短路传送门因为个人认为SPFA远不如Dijkstra，所以这里就稍微懒了些 介绍什么是SPFA算法呢？设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。松弛操作的原理是著名的定理：“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]&gt;dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。 和广搜BFS的区别：SPFA 在形式上和广度(宽度)优先搜索非常类似，不同的是BFS中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进(重新入队)，于是再次用来改进其它的点，这样反复迭代下去。 算法描述：1234567891011121314void spfa(s); //求单源点s到其它各顶点的最短距离 for i=1 to n do &#123; dis[i]=∞; vis[i]=false; &#125; //初始化每点到s的距离，不在队列 dis[s]=0; //将dis[源点]设为0 vis[s]=true; //源点s入队列 head=0; tail=1; q[tail]=s; //源点s入队, 头尾指针赋初值 while head&lt;tail do &#123; head+1; //队首出队 v=q[head]; //队首结点v vis[v]=false; //释放对v的标记，可以重新入队 for 每条边(v,i) //对于与队首v相连的每一条边 if (dis[i]&gt;dis[v]+a[v][i]) //如果不满足三角形性质 dis[i] = dis[v] + a[v][i] //松弛dis[i] if (vis[i]=false) &#123;tail+1; q[tail]=i; vis[i]=true;&#125; //不在队列，则加入队列 &#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于hexo的主题]]></title>
    <url>%2F2018%2F08%2F01%2F%E5%85%B3%E4%BA%8Ehexo%E7%9A%84%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这里有个网站，推荐了几个不错的主题，还有预览click here有两个我很喜欢yiliaTranquilpeak初步打算弄成yilia然后配置yilia主题的步骤在这里click here]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo的一些操作]]></title>
    <url>%2F2018%2F08%2F01%2Fhexo%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[迁移我找到了两个网站 click here click here不过都看不懂。。最后这个详细点click here 插入媒体可以插入图片，音乐，视频click here 这个厉害click here 相册功能看起来好难弄click here]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello the cruel world!]]></title>
    <url>%2F2018%2F07%2F31%2FHello%20the%20cruel%20world!%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
</search>
