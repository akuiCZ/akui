{"meta":{"title":"凉城听暖","subtitle":"Do What You Love，Love What You Do","description":"Do What You Love,Love What You Do","author":"凉城听暖","url":"http://FanCYu.coding.me"},"pages":[{"title":"about","date":"2018-08-12T10:06:11.000Z","updated":"2018-08-12T10:06:11.797Z","comments":true,"path":"about/index.html","permalink":"http://FanCYu.coding.me/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-08-12T10:06:02.000Z","updated":"2018-08-12T10:06:02.206Z","comments":true,"path":"tags/index.html","permalink":"http://FanCYu.coding.me/tags/index.html","excerpt":"","text":""},{"title":"photos","date":"2018-08-12T10:05:56.000Z","updated":"2018-08-12T10:05:56.505Z","comments":true,"path":"photos/index.html","permalink":"http://FanCYu.coding.me/photos/index.html","excerpt":"","text":""},{"title":"","date":"2018-08-12T10:06:29.061Z","updated":"2018-08-12T08:53:16.367Z","comments":true,"path":"photos/tool.js","permalink":"http://FanCYu.coding.me/photos/tool.js","excerpt":"","text":"\"use strict\"; const fs = require(\"fs\"); const path = \"../../photos\"; fs.readdir(path, function (err, files) { if (err) { return; } let arr = []; (function iterator(index) { if (index == files.length) { fs.writeFile(\"output.json\", JSON.stringify(arr, null, \"\\t\")); return; } fs.stat(path + \"/\" + files[index], function (err, stats) { if (err) { return; } if (stats.isFile()) { arr.push(files[index]); } iterator(index + 1); }) }(0)); });"}],"posts":[{"title":"求单源最短路——Dijkstra","slug":"Dijkstra","date":"2018-09-02T14:00:00.000Z","updated":"2018-09-03T13:36:52.490Z","comments":true,"path":"2018/09/02/Dijkstra/","link":"","permalink":"http://FanCYu.coding.me/2018/09/02/Dijkstra/","excerpt":"迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。","text":"迪科斯彻算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。 算法的思路Dijkstra算法采用的是一种贪心的策略，声明一个数组dis来保存源点到各个顶点的最短距离和一个保存已经找到了最短路径的顶点的集合：T，初始时，原点 s 的路径权重被赋为 0 （dis[s] = 0）。若对于顶点 s 存在能直接到达的边（s,m），则把dis[m]设为w（s, m）,同时把所有其他（s不能直接到达的）顶点的路径长度设为无穷大。初始时，集合T只有顶点s。然后，从dis数组选择最小值，则该值就是源点s到该值对应的顶点的最短路径，并且把该点加入到T中，OK，此时完成一个顶点，然后，我们需要看看新加入的顶点是否可以到达其他顶点并且看看通过该顶点到达其他点的路径长度是否比源点直接到达短，如果是，那么就替换这些顶点在dis中的值。然后，又从dis中找出最小值，重复上述动作，直到T中包含了图的所有顶点。 示例演示下面我求下图，从顶点v1到其他各个顶点的最短路径首先第一步，我们先声明一个dis数组，该数组初始化的值为：我们的顶点集T的初始化为：T={v1}既然是求 v1顶点到其余各个顶点的最短路程，那就先找一个离 1 号顶点最近的顶点。通过数组 dis 可知当前离v1顶点最近是 v3顶点。当选择了 2 号顶点后，dis[2]（下标从0开始）的值就已经从“估计值”变为了“确定值”，即 v1顶点到 v3顶点的最短路程就是当前 dis[2]值。将V3加入到T中。为什么呢？因为目前离 v1顶点最近的是 v3顶点，并且这个图所有的边都是正数，那么肯定不可能通过第三个顶点中转，使得 v1顶点到 v3顶点的路程进一步缩短了。因为 v1顶点到其它顶点的路程肯定没有 v1到 v3顶点短.OK，既然确定了一个顶点的最短路径，下面我们就要根据这个新入的顶点V3会有出度，发现以v3 为弧尾的有： &lt; v3,v4 &gt;,那么我们看看路径：v1–v3–v4的长度是否比v1–v4短，其实这个已经是很明显的了，因为dis[3]代表的就是v1–v4的长度为无穷大，而v1–v3–v4的长度为：10+50=60，所以更新dis[3]的值,得到如下结果：因此 dis[3]要更新为 60。这个过程有个专业术语叫做“松弛”。即 v1顶点到 v4顶点的路程即 dis[3]，通过 &lt; v3,v4&gt; 这条边松弛成功。这便是 Dijkstra 算法的主要思想：通过“边”来松弛v1顶点到其余各个顶点的路程。然后，我们又从除dis[2]和dis[0]外的其他值中寻找最小值，发现dis[4]的值最小，通过之前是解释的原理，可以知道v1到v5的最短距离就是dis[4]的值，然后，我们把v5加入到集合T中，然后，考虑v5的出度是否会影响我们的数组dis的值，v5有两条出度：&lt; v5,v4&gt;和 &lt; v5,v6&gt;,然后我们发现：v1–v5–v4的长度为：50，而dis[3]的值为60，所以我们要更新dis[3]的值.另外，v1-v5-v6的长度为：90，而dis[5]为100，所以我们需要更新dis[5]的值。更新后的dis数组如下图:然后，继续从dis中选择未确定的顶点的值中选择一个最小的值，发现dis[3]的值是最小的，所以把v4加入到集合T中，此时集合T={v1,v3,v5,v4},然后，考虑v4的出度是否会影响我们的数组dis的值，v4有一条出度：&lt; v4,v6&gt;,然后我们发现：v1–v5–v4–v6的长度为：60，而dis[5]的值为90，所以我们要更新dis[5]的值，更新后的dis数组如下图：然后，我们使用同样原理，分别确定了v6和v2的最短路径，最后dis的数组的值如下：因此，从图中，我们可以发现v1-v2的值为：∞，代表没有路径从v1到达v2。所以我们得到的最后的结果为：123456起点 终点 最短路径 长度v1 v2 无 ∞ v3 &#123;v1,v3&#125; 10 v4 &#123;v1,v5,v4&#125; 50 v5 &#123;v1,v5&#125; 30 v6 &#123;v1，v5,v4,v6&#125; 60 代码实现利用邻接表，我们可以把时间复杂度优化到O(M+N)logN,以下是用邻接表来优化这个算法的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define mem(a,b) memset(a,b,sizeof(a))using namespace std;const int inf=0x3f3f3f3f;int u[10],v[10],w[10],first[10],next[10],dist[10],vis[10],n,m,k,minn;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); //初始化 for(int i=1; i&lt;=n; i++) first[i]=-1; //读入边 mem(dist,inf); for(int i=1; i&lt;=m; i++) &#123; scanf(\"%d%d%d\",&amp;u[i],&amp;v[i],&amp;w[i]); next[i]=first[u[i]]; first[u[i]]=i; if(u[i]==1) dist[v[i]]=w[i];//初始化dis数组，表示1号顶点到其余各个顶点的最短路程 &#125; //初始化vis for(int i=1; i&lt;=n; i++) vis[i]=0; vis[1]=1;//标记起始点1已经被访问过 dist[1]=0; //迪杰斯特拉算法(Dijkstra)的核心内容 for(int i=1; i&lt;=n-1; i++) &#123; minn=inf; for(int j=1; j&lt;=n; j++) &#123; if(vis[j]==0&amp;&amp;dist[j]&lt;minn) &#123; minn=dist[j]; k=j; &#125; &#125; vis[k]=1; for(int l=first[k]; l!=-1; l=next[l]) &#123; if(w[l]&lt;inf) if(dist[k]+w[l]&lt;dist[v[l]]) dist[v[l]]=dist[k]+w[l]; &#125; &#125; for(int i=1; i&lt;=n; i++) printf(\"%d \",dist[i]); return 0;&#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://FanCYu.coding.me/tags/C/"},{"name":"图论","slug":"图论","permalink":"http://FanCYu.coding.me/tags/图论/"},{"name":"单源最短路","slug":"单源最短路","permalink":"http://FanCYu.coding.me/tags/单源最短路/"}]},{"title":"各种加速","slug":"各种加速","date":"2018-08-22T10:06:02.000Z","updated":"2018-09-03T13:36:15.471Z","comments":true,"path":"2018/08/22/各种加速/","link":"","permalink":"http://FanCYu.coding.me/2018/08/22/各种加速/","excerpt":"代码中加速非常重要 废话然而我入坑了才意识到 首先是应付卡常的加速jzyzOJ 1295通过这道题我终于体会到了输入输出优化的重要性。。。其实主要就是快读","text":"代码中加速非常重要 废话然而我入坑了才意识到 首先是应付卡常的加速jzyzOJ 1295通过这道题我终于体会到了输入输出优化的重要性。。。其实主要就是快读1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;int a[3000][3000]=&#123;&#125;;int f[3000][3000]=&#123;&#125;;int Up[3000][3000]=&#123;&#125;;int Right[3000][3000]=&#123;&#125;;int Left[3000][3000]=&#123;&#125;;inline int read()&#123; int n=1,num=0; char ch=getchar(); while(!isdigit(ch)) &#123; if(ch=='-')n=-1; ch=getchar(); &#125; while(isdigit(ch)) &#123; num=(num&lt;&lt;1)+(num&lt;&lt;3)+ch-'0'; ch=getchar(); &#125; return n*num;&#125;int main()&#123; int n,m,ans=0; n=read();m=read(); for(register int i=1;i&lt;=n;i++) for(register int j=1;j&lt;=m;j++) &#123; a[i][j]=read(); if(a[i][j]==0) &#123; Up[i+1][j]=Up[i][j]+1; Left[i][j+1]=Left[i][j]+1; &#125; &#125; for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==0) Right[i][j-1]=Right[i][j]+1; for(register int i=1;i&lt;=n;++i) for(register int j=1;j&lt;=m;++j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j-1],Left[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; memset(f,0,sizeof(f)); for(register int i=1;i&lt;=n;++i) for(register int j=m;j&gt;=1;--j) if(a[i][j]==1) &#123; f[i][j]=min(f[i-1][j+1],Right[i][j]); f[i][j]=min(f[i][j],Up[i][j])+1; ans=max(ans,f[i][j]); &#125; printf(\"%d\\n\",ans); return 0;&#125; 题目贴出来。。 这个是只用流输入输出的优化这道题给我这个教训以前，我曾以为这个优化很牛逼 这个是前面贴出代码的效果 其他优化日后更新 相信我","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://FanCYu.coding.me/tags/C/"},{"name":"优化","slug":"优化","permalink":"http://FanCYu.coding.me/tags/优化/"}]},{"title":"求单源最短路——spfa","slug":"spfa","date":"2018-08-12T10:06:02.000Z","updated":"2018-09-02T14:08:20.054Z","comments":true,"path":"2018/08/12/spfa/","link":"","permalink":"http://FanCYu.coding.me/2018/08/12/spfa/","excerpt":"设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。","text":"设立一个先进先出的队列q用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。松弛操作的原理是著名的定理：“三角形两边之和大于第三边”，在信息学中我们叫它三角不等式。所谓对结点i,j进行松弛，就是判定是否dis[j]&gt;dis[i]+w[i,j]，如果该式成立则将dis[j]减小到dis[i]+w[i,j]，否则不动。 和广搜bfs的区别：SPFA 在形式上和广度(宽度)优先搜索非常类似，不同的是bfs中一个点出了队列就不可能重新进入队列，但是SPFA中一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本身被改进(重新入队)，于是再次用来改进其它的点，这样反复迭代下去。 算法描述：1234567891011121314void spfa(s); //求单源点s到其它各顶点的最短距离 for i=1 to n do &#123; dis[i]=∞; vis[i]=false; &#125; //初始化每点到s的距离，不在队列 dis[s]=0; //将dis[源点]设为0 vis[s]=true; //源点s入队列 head=0; tail=1; q[tail]=s; //源点s入队, 头尾指针赋初值 while head&lt;tail do &#123; head+1; //队首出队 v=q[head]; //队首结点v vis[v]=false; //释放对v的标记，可以重新入队 for 每条边(v,i) //对于与队首v相连的每一条边 if (dis[i]&gt;dis[v]+a[v][i]) //如果不满足三角形性质 dis[i] = dis[v] + a[v][i] //松弛dis[i] if (vis[i]=false) &#123;tail+1; q[tail]=i; vis[i]=true;&#125; //不在队列，则加入队列 &#125;","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://FanCYu.coding.me/tags/C/"},{"name":"图论","slug":"图论","permalink":"http://FanCYu.coding.me/tags/图论/"},{"name":"单源最短路","slug":"单源最短路","permalink":"http://FanCYu.coding.me/tags/单源最短路/"}]},{"title":"关于hexo的主题","slug":"关于hexo的主题","date":"2018-08-01T10:06:02.000Z","updated":"2018-08-22T13:56:36.179Z","comments":true,"path":"2018/08/01/关于hexo的主题/","link":"","permalink":"http://FanCYu.coding.me/2018/08/01/关于hexo的主题/","excerpt":"这里有个网站，推荐了几个不错的主题，还有预览click here","text":"这里有个网站，推荐了几个不错的主题，还有预览click here有两个我很喜欢yiliaTranquilpeak初步打算弄成yilia然后配置yilia主题的步骤在这里click here","categories":[],"tags":[]},{"title":"hexo的一些操作","slug":"hexo的一些操作","date":"2018-08-01T10:06:02.000Z","updated":"2018-08-22T13:58:22.157Z","comments":true,"path":"2018/08/01/hexo的一些操作/","link":"","permalink":"http://FanCYu.coding.me/2018/08/01/hexo的一些操作/","excerpt":"迁移我找到了两个网站 click here click here","text":"迁移我找到了两个网站 click here click here不过都看不懂。。最后这个详细点click here 插入媒体可以插入图片，音乐，视频click here 这个厉害click here 相册功能看起来好难弄click here","categories":[],"tags":[]},{"title":"Violin","slug":"Violin","date":"2018-08-01T00:06:02.000Z","updated":"2018-08-22T13:57:57.256Z","comments":true,"path":"2018/08/01/Violin/","link":"","permalink":"http://FanCYu.coding.me/2018/08/01/Violin/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello the cruel world!","slug":"Hello the cruel world!","date":"2018-07-31T11:06:02.000Z","updated":"2018-09-03T13:33:40.827Z","comments":true,"path":"2018/07/31/Hello the cruel world!/","link":"","permalink":"http://FanCYu.coding.me/2018/07/31/Hello the cruel world!/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"fcy click here","slug":"fcy click here","date":"2018-07-31T10:06:02.000Z","updated":"2018-08-22T13:56:20.716Z","comments":true,"path":"2018/07/31/fcy click here/","link":"","permalink":"http://FanCYu.coding.me/2018/07/31/fcy click here/","excerpt":"","text":"博客出了一点问题整修中，不久一定会发布这篇。。。不是文章内容整修。。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-07-31T04:06:02.000Z","updated":"2018-09-03T13:34:14.963Z","comments":true,"path":"2018/07/31/hello-world/","link":"","permalink":"http://FanCYu.coding.me/2018/07/31/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment #","categories":[],"tags":[]}]}